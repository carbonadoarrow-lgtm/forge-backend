from datetime import datetime
from typing import List, Dict, Any

from fastapi import APIRouter, HTTPException

from .. import schemas
from ..storage import load_list, save_list

router = APIRouter(prefix="/chat", tags=["chat"])

SESSIONS_FILE = "chat_sessions.json"
MESSAGES_FILE = "chat_messages.json"


def _now_iso() -> str:
    return datetime.utcnow().isoformat() + "Z"


@router.get("/sessions", response_model=List[schemas.ChatSession])
def list_sessions() -> List[schemas.ChatSession]:
    return load_list(schemas.ChatSession, SESSIONS_FILE)


@router.post("/sessions", response_model=schemas.ChatSession)
def create_session(payload: Dict[str, Any]) -> schemas.ChatSession:
    title = payload.get("title") or "New session"
    sphere = payload.get("sphere") or "forge"
    context = payload.get("context") or {}

    sessions = load_list(schemas.ChatSession, SESSIONS_FILE)
    session_id = f"chat-{int(datetime.utcnow().timestamp())}"
    now = _now_iso()

    session = schemas.ChatSession(
        id=session_id,
        title=title,
        sphere=sphere,
        created_at=now,
        updated_at=now,
        pinned=False,
        context=context,
    )
    sessions.append(session)
    save_list(sessions, SESSIONS_FILE)
    return session


@router.get(
    "/sessions/{session_id}",
    response_model=schemas.ChatSession,
)
def get_session(session_id: str) -> schemas.ChatSession:
    sessions = load_list(schemas.ChatSession, SESSIONS_FILE)
    for s in sessions:
        if s.id == session_id:
            return s
    raise HTTPException(status_code=404, detail="Session not found")


@router.get(
    "/sessions/{session_id}/messages",
    response_model=List[schemas.ChatMessage],
)
def list_messages(session_id: str, limit: int = 100) -> List[schemas.ChatMessage]:
    messages = load_list(schemas.ChatMessage, MESSAGES_FILE)
    filtered = [m for m in messages if m.session_id == session_id]
    return filtered[-limit:]


@router.post(
    "/sessions/{session_id}/messages",
    response_model=List[schemas.ChatMessage],
)
def send_message(session_id: str, payload: Dict[str, Any]) -> List[schemas.ChatMessage]:
    content = payload.get("content")
    if not content:
        raise HTTPException(status_code=400, detail="content is required")

    sessions = load_list(schemas.ChatSession, SESSIONS_FILE)
    if not any(s.id == session_id for s in sessions):
        raise HTTPException(status_code=404, detail="Session not found")

    messages = load_list(schemas.ChatMessage, MESSAGES_FILE)
    now = _now_iso()

    user_msg = schemas.ChatMessage(
        id=f"msg-{int(datetime.utcnow().timestamp()*1000)}-u",
        session_id=session_id,
        role="user",
        content=content,
        created_at=now,
        meta={},
    )
    messages.append(user_msg)

    # Stub assistant reply; later this will call the Consult Bridge.
    assistant_msg = schemas.ChatMessage(
        id=f"msg-{int(datetime.utcnow().timestamp()*1000)}-a",
        session_id=session_id,
        role="assistant",
        content=(
            "This is a stubbed Forge advisory reply.\n\n"
            "In live mode, this will be generated by the Consult Bridge using "
            "mission/run/context attached to this session."
        ),
        created_at=_now_iso(),
        meta={},
    )
    messages.append(assistant_msg)

    save_list(messages, MESSAGES_FILE)

    # Update session.updated_at
    for s in sessions:
        if s.id == session_id:
            s.updated_at = _now_iso()
    save_list(sessions, SESSIONS_FILE)

    return [user_msg, assistant_msg]
