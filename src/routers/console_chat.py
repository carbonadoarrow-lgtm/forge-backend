"""
Console Chat Router - Operator chat interface with Forge OS.

This provides a dedicated chat interface for operators to interact with
Forge OS for general queries, troubleshooting, and advisory conversations.
"""

from typing import List, Dict, Any
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

from ..console_chat_store import (
    console_chat_store,
    ConsoleChatSession,
    ConsoleChatMessage,
)


router = APIRouter(prefix="/console/chat", tags=["console-chat"])


# Request models
class CreateSessionRequest(BaseModel):
    title: str | None = None
    sphere: str = "forge"
    context: Dict[str, Any] | None = None


class SendMessageRequest(BaseModel):
    content: str


# Endpoints
@router.get("/sessions", response_model=List[ConsoleChatSession])
def list_chat_sessions() -> List[ConsoleChatSession]:
    """
    List all console chat sessions, sorted by most recently updated.

    These are operator chats with Forge OS - for general queries,
    troubleshooting, and advisory conversations.
    """
    return console_chat_store.list_sessions()


@router.post("/sessions", response_model=ConsoleChatSession)
def create_chat_session(body: CreateSessionRequest) -> ConsoleChatSession:
    """
    Create a new console chat session.

    Operators can create sessions to ask questions, get advice,
    troubleshoot issues, etc.
    """
    return console_chat_store.create_session(
        title=body.title or "New session",
        sphere=body.sphere,
        context=body.context or {},
    )


@router.get("/sessions/{session_id}", response_model=ConsoleChatSession)
def get_chat_session(session_id: str) -> ConsoleChatSession:
    """
    Get a specific chat session by ID.
    """
    session = console_chat_store.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")
    return session


@router.get("/sessions/{session_id}/messages", response_model=List[ConsoleChatMessage])
def list_chat_messages(session_id: str) -> List[ConsoleChatMessage]:
    """
    List all messages in a chat session, in chronological order.
    """
    session = console_chat_store.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")

    return console_chat_store.list_messages(session_id)


@router.post("/sessions/{session_id}/messages", response_model=List[ConsoleChatMessage])
def send_chat_message(session_id: str, body: SendMessageRequest) -> List[ConsoleChatMessage]:
    """
    Send a message in a chat session.

    This adds the user's message and generates a stubbed assistant reply.
    In production, the assistant reply will be generated by the Consult Bridge
    using the session context.
    """
    session = console_chat_store.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")

    # 1. Store user message
    console_chat_store.add_message(session_id, "user", body.content)

    # 2. Generate stubbed assistant reply
    # TODO: Replace with real LLM/Consult Bridge integration
    reply = (
        "This is a stubbed Forge OS advisory reply.\n\n"
        "In live mode, this will be generated by the Consult Bridge using "
        "mission/run/context attached to this session."
    )
    console_chat_store.add_message(session_id, "assistant", reply)

    # 3. Return all messages
    return console_chat_store.list_messages(session_id)


@router.post("/sessions/{session_id}/mark-read")
def mark_session_read(session_id: str) -> Dict[str, str]:
    """
    Mark all messages in a session as read (reset unread_count).

    This should be called when the operator views the session.
    """
    session = console_chat_store.get_session(session_id)
    if not session:
        raise HTTPException(status_code=404, detail="Session not found")

    console_chat_store.mark_read(session_id)
    return {"status": "ok"}
